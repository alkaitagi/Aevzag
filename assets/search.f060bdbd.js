import{d as s,r as e,E as t}from"./vendor.c8bf7c27.js";function i(s,e){switch(e[0]){case"!":return s===e.substr(1);case"+":return s.startsWith(e.substr(1));case"-":return s.endsWith(e.substr(1));default:return s.includes(e)}}function n(s,e,t,n){if("#"===e[0])return function(s,e){var t;return e=e.substr(1),(null==(t=s.tags)?void 0:t.includes(e))?s.uses.map((s=>s.meaning)):s.uses.filter((s=>{var t;return null==(t=s.tags)?void 0:t.includes(e)})).map((s=>s.meaning))}(s,e);const r=[];return t&&s.forms.some((s=>i(s.plain,e)))&&r.push(...s.uses.map((s=>s.meaning))),n&&r.push(...s.uses.map((s=>s.meaning)).filter((s=>i(s,e)))),r}function r(s,e,t,i){const r=new Set;for(const a of e){let e=s.uses.map((s=>s.meaning));for(const r of a){const a=n(s,r,t,i);e=e.filter((s=>a.includes(s)))}e.forEach((s=>r.add(s)))}return[...r]}class a{constructor(i){this.lects=s((()=>{var s,e;return Object.keys(null!=(e=null==(s=this.dictionaries)?void 0:s.value)?e:{})})),this.progress=e({}),this.results=e({}),this.pending=null,this.executing=e(!1),this.dictionaries=i,this.reset(),t((()=>this.stop()))}reset(){this.lects.value.forEach((s=>this.progress.value[s]=0)),this.progress.value[""]=0,this.results.value={}}async sleep(s=10){return new Promise((e=>setTimeout(e,s)))}addResult(s,e,t){for(const i of e)this.results.value[i]||(this.results.value[i]={}),this.results.value[i][s]||(this.results.value[i][s]=[]),this.results.value[i][s].push(t)}async queryDictionary(s,e,t,i,n){for(let a=0;a<e.length;a++){const u=r(e[a],t,i,n);if(u.length&&this.addResult(s,u,e[a]),this.pending)return;a%1e3||(this.progress.value[s]=a/e.length,await this.sleep())}this.progress.value[s]=1}async findMeanings(s,e){const t=new Set;for(let i=0;i<s.length;i++){if(r(s[i],e,!0,!1).forEach((s=>t.add(s))),this.pending)return[];i%1e3||(this.progress.value[""]=i/s.length,await this.sleep())}return this.progress.value[""]=1,[...t].map((s=>["!"+s]))}async queue(s){const e=async()=>{if(this.pending=null,this.executing.value=!0,await s(),this.executing.value=!1,this.pending){const s=this.pending;this.pending=null,s()}};this.executing.value?this.pending=e:e()}stop(){this.queue((()=>console.log("searcher stopped")))}search(s,e){this.queue((async()=>{this.reset();let t=e.toLowerCase().split(".").map((s=>s.split(" ").map((s=>s.trim())).filter((s=>s)))).filter((s=>s.length));if(t.length){if(1===this.lects.value.length)return s=this.lects.value[0],void(await this.queryDictionary(s,this.dictionaries.value[s],t,!0,!0));t.length&&s&&(t=await this.findMeanings(this.dictionaries.value[s],t)),t.length&&await Promise.all(Object.entries(this.dictionaries.value).map((s=>this.queryDictionary(...s,t,!1,!0))))}}))}}export{a as S};
